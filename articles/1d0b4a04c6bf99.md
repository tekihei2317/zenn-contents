---
title: "TypeScriptで業務アプリを試作してみた（tRPC+Prisma+Next.js）"
emoji: "💐"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["typescript", "prisma", "trpc"]
published: false
---

TypeScriptで業務アプリケーションを試作してみたので、作っているときに考えたことについて書こうと思います。

なぜTypeScriptで業務アプリケーションを作ってみたかというと、Domain Modeling Made Functionalという本を読んだことがきっかけです。Domain Modeling Made Functional（以降DMMF）は、F#で現実のモデルに基づいた堅牢なアプリケーションを作る方法について書かれた本です。

本の内容が素晴らしかったので、TypeScriptで実践するにはどうすればいいのかが気になりました。また、DMMFではデータベースとのやりとりがモックで実装されていたり、1つのワークフロー（商品の注文）しか扱っていません。そのため、本格的なケースで試してみようと思いました。

## 作ったもの

花束問題というデータモデリングの問題に基づいた、在庫管理アプリケーションを作りました。

花束問題は、次のような問題です。

ソースコードとアプリケーションはこちらにあります。現在はユーザー登録ができないため、動作確認してみたい場合はクローンして確認していただければと思います。

次のフレームワークやライブラリを使って開発しました。

- Next.js
- Mantine
- tRPC
- Prisma

## 実装する前に考えること

### まずは問題を正しく理解する

DMMFにも書かれていることですが、ソフトウェア開発者の仕事はコードを書くことではなく、問題を解決することです。問題を解決するためには、問題を正しく理解する必要があります。問題を正しく理解するためには、例えば次のことが重要です。

- 問題に詳しい人（ドメインエキスパート）と対話する
- 実際の現場で何が行われているかを観察する

もし花束問題が現実の問題だとすると、実際に花屋さんに行ってお店の人と話をしてみたり、花屋さんがどのように仕入れをしているのか、在庫を管理しているのかを観察してみるのがよいのかなと思います。

### システムの全体像を図に書き起こす

DMMFではイベントストーミングというワークショップが紹介されています。イベントストーミングは、業務の全体像や手順を把握したり、プロジェクトに関わる人たちの間で共通理解を作るためのワークショップです。

イベントストーミングは複数人で行うワークショップですが、成果物はシステムの全体像を把握するために役に立つためやってみました。その結果、このシステムは5つのコンテキストに分けるとよさそうだということが分かりました。

### 業務の手順を自然言語で記述する

## データベースの設計

### データベースはアプリケーションの心臓

### 業務の手順と画面設計があると、データベースの設計がやりやすい

### テーブルの設計で重要なポイント

### テーブルの具体的な設計例

## 実装について

### 実装がシンプルにまとまる見込みがある場合は、素直に書き下す

例えば更新系の場合は、バリデーション+データベースの更新+αくらいであれば、プロシージャ（コントローラー、リゾルバ）に処理を書き下して問題ないと思います。

具体的には次のような感じです。

```ts
/**
 * 花を更新する
 */
export const updateFlower = adminProcedure.input(UpdateFlowerInput).mutation(async ({ ctx, input }) => {
  const updatedFlower = await ctx.prisma.flower.update({
    where: { id: input.id },
    data: input,
  });

  return updatedFlower;
});
```

参照系の場合は、特に戻り値の型は指定せずにtRPCに推論させている箇所が多いです。なぜかというと、画面に必要なデータは比較的変更が多いためです。

```ts
/**
 * 注文を取得する
 */
export const getOrder = adminProcedure.input(OrderIdInput).query(async ({ ctx, input }) => {
  const order = await ctx.prisma.bouquetOrder.findUnique({
    where: { id: input.orderId },
    select: {
      id: true,
      bouquet: { select: { id: true, name: true } },
      customer: { select: { name: true } },
      deliveryDate: true,
      senderName: true,
      deliveryAddress1: true,
      deliveryAddress2: true,
      deliveryMessage: true,
      shipment: true,
    },
  });
  if (order === null) throw notFoundError;

  return {
    ...order,
    status: getOrderStatus(order),
  };
});
```

### 書き下すと大きくなる場合は、データの型を定義して関数に分割する

更新系は特に、プロシージャに書き下すと見通しが悪くなりがちです。そのため、データの型を定義してそれを使う関数に分割します。

例えば、お客さんが花束を注文する機能の実装を考えてみます。これは次のようにモデリングしていました。

```text
workflow 花束を注文する =
  input: 花束の注文フォーム
  output: 花束の注文

  注文フォームの内容が正しいかを確認する
  在庫を確認する（注文して間に合うかを確認する）
  花束の金額の請求を行う
```

まずは、データの型や関数の型を定義します。

```ts:server/src/context-auth/core/types.ts
export type Customer = {
  id: number;
  email: string;
  name: string;
};
```

```ts:server/src/context-order/core/types.ts
export type ValidatedOrder = {
  customerId: number;
  senderName: string;
  bouquetId: number;
  deliveryDate: Date;
  deliveryAddress1: string;
  deliveryAddress2?: string | undefined;
  deliveryMessage?: string | undefined;
  totalAmount: number;
  orderDetails: ValidatedOrderDetail[];
};

export type PlacedOrder = {
  id: number;
  customerId: number;
  senderName: string;
  bouquetId: number;
  deliveryDate: Date;
  deliveryAddress1: string;
  deliveryAddress2: string | null;
  deliveryMessage: string | null;
  totalAmount: number;
};
```

```ts
// zodから導出した型
import { PlaceOrderForm } from "./api-schema";

function validateOrderForm(orderForm: PlaceOrderForm, customer: Customer): ValidatedOrder {
}

async function checkStock(order: ValidatedOrder): Promise<boolean> {
}

async function persistOrder(order: ValidatedOrder): Promise<PlacedOrder> {
}

async function processPayment(order: PlacedOrder): Promise<void> {}
```

このようにすれば、プロシージャの中を見ればどのような処理をしているのかが一目で分かるので、見通しが良いです。

```ts
export const placeOrder = customerProcedure.input(PlaceOrderForm).mutation(async ({ input, ctx }) => {
  const validatedOrder = await validateOrderForm(input, ctx.user);
  if (!(await checkStock(validatedOrder))) {
    throw new TRPCError({
      code: "BAD_REQUEST",
      message: "在庫が不足しているため、指定したお届け日にお届けできません。",
    });
  }

  const placedOrder = await persistOrder(validatedOrder);
  await processPayment(placedOrder);

  return placedOrder;
});
```

実装が手探りで、最初からデータの型を定義しにくい場合もあると思います。その場合は、後から関数に分けるといいと思います。

### 複雑になってきた場合は3つのレイヤーに分ける

これまでは、プロシージャに関する処理はほとんど1ファイルに書いてきました。コードの量が多くなってくると、見通しが悪くなってきます。最近は、importが複雑になることがリファクタリングの目安になるのかなと思っています。

その場合は、次の3つのレイヤーに分けると綺麗になると思います。

1. procedureのように、なんでも書いてよい場所
2. データベースに関する処理を書く場所
3. HTTPやDBに依存しない、純粋なロジックを書く場所

今回は、この3つに分けたのは在庫推移の取得機能です。必要な情報をいろいろなテーブルから取得したり、その情報から計算する処理があります。

2は`persistence/`ディレクトリ、3は`core`ディレクトリに置くことにしました。

## これから試すこと

まずは、プロシージャのテストを書きたいです。仕事のプロジェクトでは、Quramyさんの`jest-prisma`と`prisma-fabbrica`を使ってデータベースのテストを書いています。[Jestではじめるテスト入門](https://peaks.cc/books/testing_with_jest)を読んで参考にしたいと思います。

次に、ESLintで依存関係のチェックをできるようにしたいです。チェックしたい依存関係は、コンテキスト間の依存関係と、コンテキスト内の依存関係です。

コンテキスト間の依存関係をチェックする場合は、PrismaClientを直接使うのではなく、コンテキストごとにモデルを配置するといいかもしれないと思いました（例えば、注文のコンテキストで`export orderModel = prisma.order`とする）。

Result型の導入も検討したいです。現状では、プロシージャを置いているファイルの関数では`TRPCError`をスローしています。Result型を使うと、失敗する可能性がある処理であることが関数のインターフェイスから分かるので、いずれtRPCErrorをスローするとしてもメリットがありそうです。

## 振り返り

## まとめ

TypeScriptで業務アプリケーションを試作してみて、考えたことや実装して気づいたことについて書きました。

Domain Modeling Made Functionalから学んだ重要なことは、問題を正しく理解すること・システムの全体像を把握してコンテキストに分けること・自然言語で業務の手順を整理することが重要であることを学びました。

実装面では、データに正確な型をつけることや、ワークフローを入出力が明確な関数の集まりで構成することが重要なことを学びました。

Domain Modeling Made Functionalにはあまり書かれていませんが、システムを作る上ではデータベースの設計が非常に重要です。データベースには事実を保存するようにし、変更を避けることが重要だと学びました。
