---
title: "Node.jsのconnectをコードリーディングしてみる"
emoji: "🤖"
type: "tech"
topics: ["nodejs"]
published: false
---

connectは、Node.jsのHTTPサーバーにミドルウェアを追加するためのライブラリです。

https://github.com/senchalabs/connect

ここでのミドルウェアは、リクエストの処理の前や後に共通処理を実行するもののことです。具体的には、セッションを有効化したり、ログを出力したりします。

connectはexpressの3系まで使われていましたが、4系になったときにexpressから削除されたようです。今回はconnectの3.7.0を読みました。[senchalabs/connect at 3.7.0](https://github.com/senchalabs/connect/tree/3.7.0)

## connectを使ってみる

リクエストが来たら`Hello, world`を返すHTTPサーバーを作成しました。ログを出力するミドルウェアを2つと、レスポンスに書き込むミドルウェアの合計3つを追加しています。

```js:playground/index.js
const connect = require("connect")

const app = connect();
app.use(function(req, res, next) {
  console.log('middleware 1');
  next();
});

app.use(function(req, res, next) {
  console.log('middleware 2');
  next();
});

app.use(function(req, res) {
  res.end("Hello, world!")
})

app.listen(3000);
```

```
$ node playground/index.js
# 別の端末でcurlを実行すると以下が表示される
middleware 1
middleware 2

$ curl localhost:3000
Hello, world!
```

## 読んでみる

### エントリーポイント

connectは単一ファイルのライブラリです。`require`で読み込まれるのは、エントリーポイントの`index.js`でエクスポートしている`createServer`です。

`createServer`では、`app`という関数を定義した後、`app`にいくつかのプロパティを追加しています。

```js:index.js
// 関係なさそうなところは省略
module.exports = createServer;

var finalhandler = require('finalhandler');
var http = require('http');
var merge = require('utils-merge');
var proto = {};

function createServer() {
  function app(req, res, next){ app.handle(req, res, next); }
  merge(app, proto);
  merge(app, EventEmitter.prototype);
  app.route = '/';
  app.stack = [];
  return app;
}
```

`app.handle`の`handle`は、後ろのコードで`proto`に追加されていて、それが`merge(app, proto)`で`app`に追加されています。「`app`の中で`app`を参照できるのか？」と思いましたが、再帰関数を書くときもそうしていたことを思い出して納得しました。

### app.use(fn)

`app.use`は、渡したミドルウェアを`stack`という配列に追加します。

```js:index.js
proto.use = function use(route, fn) {
  var handle = fn;
  var path = route;

  // default route to '/'
  if (typeof route !== 'string') {
    handle = route;
    path = '/';
  }

  // 省略

  // add the middleware
  debug('use %s %s', path || '/', handle.name || 'anonymous');
  this.stack.push({ route: path, handle: handle });

  return this;
};
```

`use`では第一引数にパスを指定できますが、あまり使わなさそうな機能だったので今回は読み飛ばしました。

### app.listen([…])

`http.createServer`でHTTPサーバーを作成して、`listen`で接続待ちしています。

```js:index.js
proto.listen = function listen() {
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};
```

`http.createServer`には、[requestイベント](https://nodejs.org/api/http.html#event-request)に紐付けられるリスナーを渡します。thisは呼び出された関数が属するオブジェクト（実行コンテキスト）を表すので、この場合はapp関数のことです。

次の行は見慣れない処理でしたが、これは`server.listen(arguments)`とほぼ同じです。可変長引数を実現するために`Function.prototype.apply`が使われています。

`app`の中では`app.handle`が実行されているので、次は`app.handle`を読みます。

### app.handle

ここがconnectのメインの処理です。`handle`では、ミドルウェアを順番に実行します。finalhandlerは、エラーの内容に応じたエラーレスポンスを返すためのライブラリです。

```js:index.js
// パスに関するところは省略
proto.handle = function handle(req, res, out) {
  var index = 0;
  var stack = this.stack;

  // final function handler
  var done = out || finalhandler(req, res, {
    env: env,
    onerror: logerror
  });

  function next(err) {
    // next callback
    var layer = stack[index++];

    // all done
    if (!layer) {
      defer(done, err);
      return;
    }

    // route data
    var path = parseUrl(req).pathname || '/';
    var route = layer.route;

    // call the layer handle
    call(layer.handle, route, err, req, res, next);
  }

  next();
};
```

`handle`の中では、`next`という、ミドルウェアを呼び出してポインタを進める関数を作成し、`call`に`next`を渡しています。ミドルウェアの中で`next`を実行するので、ちょっと分かりにくいですがこれは再帰関数になっています。

### call

`call`はミドルウェアの実行を担当する関数です。`Function.prototype.length`で引数の個数を取得し、4個かそれ未満かどうかで分岐しています。引数が4個のミドルウェアは、エラーミドルウェアという、エラーハンドリングを担当する特別なミドルウェアです。

```js:index.js
function call(handle, route, err, req, res, next) {
  var arity = handle.length;
  var error = err;
  var hasError = Boolean(err);

  debug('%s %s : %s', handle.name || '<anonymous>', route, req.originalUrl);

  try {
    if (hasError && arity === 4) {
      // error-handling middleware
      handle(err, req, res, next);
      return;
    } else if (!hasError && arity < 4) {
      // request-handling middleware
      handle(req, res, next);
      return;
    }
  } catch (e) {
    // replace the error
    error = e;
  }

  // continue
  next(error);
}
```

ミドルウェアで例外が発生しない場合は、`app.handle()`→`next()`→1つ目のミドルウェアが実行→1つ目の中で`next()`→2つ目のミドルウェアが実行→2つ目の中で`next()`→…というように、通常のミドルウェアがすべて実行されます。この場合は、エラーミドルウェアは実行されません。

□が普通のミドルウェアで、■がエラーミドルウェアです。

![](https://i.gyazo.com/b28350cb5c3f64838191deb9b6082200.jpg)

ミドルウェアの実行で例外が発生した場合は、`next(error)`が実行され、一番近くにあるエラーミドルウェアが実行されます。ミドルウェアの実行が続くかどうかは、エラーミドルウェアの中で`next()`を実行するかによります。

エラーミドルウェアでは、後続のエラーミドルウェアに引き継ぐために`next(err)`を実行するか、nextを実行しないかのどちらかになると思います。

![](https://i.gyazo.com/0f92bb297e73f629d326d13c9fea89b6.jpg)

## まとめ

- connectは、HTTPサーバーにミドルウェアの機能を提供するためのライブラリ
- ミドルウェアの引数の`next`は、自身以降のミドルウェアを再帰的に呼び出す関数
  - つまり、`next()`以降に書いた処理は、以降のミドルウェアの実行が完了してから実行される
- connectの引数が4個のミドルウェアは、ミドルウェアの実行で例外が発生したときだけ呼び出される特別なミドルウェア

`next`をミドルウェアの引数に渡すところが理解しづらかったので、その部分だけ自分で書いてみました。

https://github.com/tekihei2317/playground/tree/main/middleware-pattern
