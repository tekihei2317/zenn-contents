---
title: "データベースのロックの基礎からデッドロックまで"
emoji: "🦁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["データベース", "MySQL"]
published: false
publication_name: "gibjapan"
---

データベースのロックについて、資料を読んだり実際に試してみたので、学んだことを整理してみようと思います。始めにロックについての基本的な知識を整理して、最終的にはデッドロックとその対策について説明します。

## ロックとは何か（概要）

ロックはデータの更新を正しく行うための仕組みの一つで、トランザクションの実行順を制御するためのものです。ここで、データを正しく更新するとはどういうことかを説明するために、振込を例に考えてみます。

例えば、口座Aから口座Bに振込を行うとします。このとき、口座Aの出金処理と口座Bの入金処理は、必ず両方が成功しなければなりません。このための仕組みは、皆さんご存じの通りトランザクションです。

TODO: 図を入れる

また、口座Bへの入金が同じようなタイミングで起きたとします。このとき、参照と更新が次のような順序で行われることを防ぐ必要があります。このための仕組みがロックです。

TODO: 図を入れる

## ロックとは何か（詳細）

ロックとは「トランザクションの実行順を制御するための仕組み」でした。トランザクションの実行順を制御するというのは、同時に行われると問題が起きる処理を直列に実行するということです。そうするためには、あるデータを変更できるトランザクションを1つまでに制限すれば良いです。

### ロックの種類には何があるか

変更できるトランザクションを1つまでに制限する仕組みが、排他ロックといいます。排他ロックは、「これからこのデータを変更するので、他のトランザクションは処理を待ってね」ということを表します。

ロックにはもう1種類あり、共有ロックといいます。共有ロックは、トランザクション内で読み取りを行なっていることを示すためのロックです。後続の処理で変更はしないけど、変更されると問題が発生するケースで使います。

排他ロックと共有ロックは、かけられたデータが他のトランザクションから変更できないという点は同じです。トランザクション内で書き込みを行う場合は、排他ロックを使用します。排他ロックと共有ロックの共通点と違いをまとめてみると、次のようになります。

|            | 他のTXから読み取れる | 他のTXから書き込める | 自分のTXから書き込める | 他のTXから排他ロックを取得できる | 他のTXから共有ロックを取得できる |
| ---------- | -------------------- | -------------------- | ---------------------- | -------------------------------- | -------------------------------- |
| 排他ロック | o                    | x                    | o                      | x                                | x                                |
| 共有ロック | o                    | x                    | △                      | x                                | o                                |

共有ロックで△になっているのは、他のTXが共有ロックを取得していなければでき、取得している場合はできないからです。しかし、共有ロックを取得したデータを変更することは、後述するデッドロックの原因になるため推奨されません。

### ロックの取得するにはどうすればよいか

メモ: ここまでの内容を確認できるようにしたいです。共有ロックは複数のTXから取得できること、排他ロックは1つのTXしか取得できないこと、ロックを取得できない場合は解放待ちになること、TXを終了するとロックが解放されること、などです。排他ロックを取得するにはSELECT FOR UPDATE、共有ロックを取得するためにはSELECT FOR SHARE。またUPDATEやDELETEでも排他ロックが取得されることを確認したいです。

### ここまでの整理

ここまでの内容を、Q & A形式で整理してみます。

:::details データベースのロックは何のための仕組みなのか？
トランザクションの実行順序を制御するための仕組みです。ロックを使うことで、同じデータを更新するトランザクションを直列に実行させることができます。
:::

:::details ロックをすると、他のトランザクションから読み取れなくなるのか？
いいえ！ロックを取得しない読み取り（通常のSELECT）は行えます。
:::

:::details 排他ロックと共有ロックはそれぞれどういう目的のロックなのか？
排他ロックは「データを変更するため」のロックで、共有ロックは「読み取りを行っていることを示す」ためのロックです。
:::

:::details 排他ロックと共有ロックの違いは何か？
変更行うTXは1つまでのため、排他ロックは複数のTXが取得できますが、共有ロックは複数のTXが取得できます。
:::

:::details 排他ロックと共有ロックの共通点は何か？
どちらも、他のTXからの更新を禁止します。
:::

:::details ロックを取得するにはどのようにすればよいのか？
SELECT … FOR UPDATE（排他ロック）や、SELECT … FOR SHARE（共有ロック）で取得できます。また、UPDATEやDELETEの実行時には、対象のレコードに排他ロックがかけられます。
:::

:::details ロックが解放されるのはどのタイミングか？
ロックは、トランザクションが終了したタイミングで解放されます。
:::

## 最初の問題をロックで解決する

それでは、最初の振込の問題をロックを使って解決してみましょう。どのような問題だったかというと、口座A→口座B、口座C→口座Bへの入金が同じタイミングで起こり、口座Bの入金金額がおかしくなってしまうという問題です。

解決するためには、入金処理を開始するときに2つの口座の排他ロックを取得すればよいです。

```sql
begin;
select * from accounts where id = {id_from} for update;
select * from accounts where id = {id_to} for update;
update accounts set balance = balance - {amount} where id = {id_from};
update accounts set balance = balance + {amount} where id = {id_to};
commit;
```

こうすることで、同じ口座に関する処理は順番に行われるため、口座Bの金額がおかしくなることを防げます。

TODO: 図を入れる

## デッドロックとは何か

最後に、デッドロックについて説明します。デッドロックとは、複数のトランザクションが互いに完了待ちになってしまうことをいいます。定義から分かるように、デッドロックは共有ロックだけを使う場合は起きません（解放待ちにならないため）。つまり、共有ロック・排他ロックが両方使われる場合と、排他ロックが複数使われる場合に発生します。

少々無理やりですが、2種類のデッドロックを起こしてみようと思います。

### 共有ロックと排他ロックでデッドロックが発生する例

```sql
```

### 複数の排他ロックでデッドロックが発生する例

```sql
```

## デッドロックが起こらないようにするためには

デッドロックが起こる原因は、更新するのに共有ロックを取得している場合や、トランザクションでの更新順序が一定でないことです。つまり、更新する場合は排他ロックを取得することと、トランザクションでの更新順序を一定にすることを守れば防げるはずです。

理解を深めるために、現実での具体的な例を3つ見てみることにします。

### 1 on 1チャットサービスの例

### 出金サービスの例

### 在庫管理システムの例

## まとめ

- データを正しく更新するためのデータベースの仕組みには、トランザクションとロックがある
- ロックは、あるデータに対するトランザクション内の更新順序を制御するためのもの
- ロックには、データの更新を行うための排他ロックと、データを読み取っている（= 変更しないでほしい）ことを示すための共有ロックがある
- ロックするが既にロックされている場合は、ロックの解放待ち（トランザクションの終了待ち）になる。
- レコードロックを取得する代表的な方法には、ロック読み取り（SELECT … FOR UPDATE、SELECT … FOR SHARE）と、UPDATE文・DELETE文がある。UPDATEやDELETEでは、レコードに排他ロックが設定される。
- 複数のトランザクションが互いに終了待ちになることをデッドロックという。デッドロックが発生すると、片方のトランザクションが強制的に終了される（？）
- デッドロックの原因には、データの更新を行うのに共有ロックを取得している場合や、データを更新する順序（排他ロックの取得順序）が一定でないことがある。デッドロックを防ぐためには、これらが起きないようにする。
